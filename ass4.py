# -*- coding: utf-8 -*-
"""Assignment4.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1_zNZg1Jv04ziaXYgeLkAX9N9mdBEWe70
"""

from queue import PriorityQueue

goal_state = [[1, 2, 3], [4, 5, 6], [7, 8, 0]]

def h_misplaced(state):
    return sum(state[i][j] != goal_state[i][j] and state[i][j] != 0
               for i in range(3) for j in range(3))

def get_neighbors(state):
    moves = []
    x, y = next((i, j) for i in range(3) for j in range(3) if state[i][j] == 0)
    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]

    for dx, dy in directions:
        nx, ny = x + dx, y + dy
        if 0 <= nx < 3 and 0 <= ny < 3:
            new_state = [row[:] for row in state]
            new_state[x][y], new_state[nx][ny] = new_state[nx][ny], new_state[x][y]
            moves.append(new_state)
    return moves

def best_first_search(start_state):
    visited = set()
    pq = PriorityQueue()
    pq.put((h_misplaced(start_state), 0, start_state, []))

    while not pq.empty():
        h, steps, current, path = pq.get()
        state_tuple = tuple(map(tuple, current))
        if current == goal_state:
            for step in path + [current]:
                for row in step:
                    print(row)
                print()
            print(f"Total moves: {steps}")
            return

        if state_tuple in visited:
            continue
        visited.add(state_tuple)

        for neighbor in get_neighbors(current):
            if tuple(map(tuple, neighbor)) not in visited:
                pq.put((h_misplaced(neighbor), steps + 1, neighbor, path + [current]))

initial_state = [[1, 2, 3], [4, 0, 6], [7, 5, 8]]
best_first_search(initial_state)

def hill_climbing(start_state):
    current = start_state
    path = [current]
    while True:
        neighbors = get_neighbors(current)
        current_h = h_misplaced(current)
        next_state = min(neighbors, key=h_misplaced)
        next_h = h_misplaced(next_state)

        if next_h >= current_h:
            break
        current = next_state
        path.append(current)

    for step in path:
        for row in step:
            print(row)
        print()
    print(f"Total moves: {len(path)-1}")

initial_state2 = [[2, 8, 3], [1, 6, 4], [7, 0, 5]]
hill_climbing(initial_state2)

def h_correctly_placed(state):
    return sum(state[i][j] == goal_state[i][j] for i in range(3) for j in range(3))

def a_star_search(start_state):
    visited = set()
    pq = PriorityQueue()
    pq.put((0 - h_correctly_placed(start_state), 0, start_state, []))

    while not pq.empty():
        f, g, current, path = pq.get()
        state_tuple = tuple(map(tuple, current))

        if current == goal_state:
            for step in path + [current]:
                for row in step:
                    print(row)
                print()
            print(f"Total moves: {g}")
            return

        if state_tuple in visited:
            continue
        visited.add(state_tuple)

        for neighbor in get_neighbors(current):
            if tuple(map(tuple, neighbor)) not in visited:
                hn = h_correctly_placed(neighbor)
                pq.put(((g + 1) - hn, g + 1, neighbor, path + [current]))


initial_state3 = [[2, 8, 3], [1, 6, 4], [7, 0, 5]]
a_star_search(initial_state3)

class Node:
    def __init__(self, name):
        self.name = name
        self.children = []
        self.heuristic = 0
        self.solved = False
        self.best_cost = float('inf')
        self.best_children = []


nodes = {ch: Node(ch) for ch in 'ABCDEFGH'}


nodes['A'].children = [
    ('AND', 16, [nodes['B'], nodes['D']]),
    ('OR', 12, [nodes['C']])
]
nodes['B'].children = [
    ('AND', 12, [nodes['G'], nodes['H']])
]
nodes['D'].children = [
    ('AND', 8, [nodes['E'], nodes['F']])
]


for leaf in ['C', 'E', 'F', 'G', 'H']:
    nodes[leaf].solved = True
    nodes[leaf].best_cost = 0

# AO* implementation
def ao_star(node):
    if node.solved:
        return node.best_cost

    min_cost = float('inf')
    best_option = None

    for conn_type, base_cost, children in node.children:
        total_cost = base_cost
        all_solved = True
        for child in children:
            cost = ao_star(child)
            total_cost += cost
            if not child.solved:
                all_solved = False

        if total_cost < min_cost:
            min_cost = total_cost
            best_option = (conn_type, children)

    node.best_cost = min_cost
    node.best_children = best_option[1]
    node.solved = all(child.solved for child in best_option[1])

    return node.best_cost

def print_solution(node, indent=0):
    print("  " * indent + f"{node.name} (Cost: {node.best_cost})")
    for child in node.best_children:
        print_solution(child, indent + 1)


root = nodes['A']
ao_star(root)
print("Optimal Path:")
print_solution(root)