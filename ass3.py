# -*- coding: utf-8 -*-
"""ASS3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1xgng6yl2bV4s8-YoUGwbLTtmdEQphuDL
"""

from collections import deque

def blocks_world_bfs(initial, goal):
    """
    Solves the blocks world problem using BFS

    Args:
        initial: Initial state (list of stacks/lists)
        goal: Goal state (list of stacks/lists)

    Returns:
        List of moves to reach goal state, or None if no solution
    """
    queue = deque([(initial, [])])  # Stores (state, path_to_state)
    visited = set()  # Tracks visited states

    while queue:
        state, path = queue.popleft()  # Get next state to explore

        # Check if current state matches goal
        if state == goal:
            return path

        # Convert state to tuple-of-tuples for hashing
        state_tuple = tuple(tuple(stack) for stack in state)
        if state_tuple in visited:
            continue

        visited.add(state_tuple)  # Mark state as visited

        # Generate all possible moves
        for i in range(len(state)):
            if state[i]:  # If stack is not empty
                block = state[i][-1]  # Get top block

                # Try moving to all other stacks
                for j in range(len(state)):
                    if i != j:  # Don't move to same stack
                        # Create new state
                        new_state = [list(stack) for stack in state]
                        new_state[i].pop()  # Remove from source stack
                        new_state[j].append(block)  # Add to target stack

                        # Add to queue with updated path
                        move_desc = f"Move {block} from Stack {i+1} to Stack {j+1}"
                        queue.append((new_state, path + [move_desc]))

    return None  # No solution found

# Example usage:
if __name__ == "__main__":
    # Define initial and goal states
    initial = [['A', 'B', 'C'], [], []]  # Stack 0 has C on B on A
    goal = [['A', 'B', 'C'], [], []]     # Goal is same as initial (test case)

    # Alternative test case:
    # initial = [['A', 'C'], ['B'], []]
    # goal = [['A', 'B', 'C'], [], []]

    solution = blocks_world_bfs(initial, goal)

    if solution:
        print("BFS Solution (shortest path):")
        for i, step in enumerate(solution, 1):
            print(f"{i}. {step}")
    else:
        print("No solution found")



import copy

def blocks_world_dfs(initial, goal):
    stack = [(initial, [])]
    visited = set()

    while stack:
        state, path = stack.pop()

        # Convert state to a hashable type for comparison
        state_key = tuple(tuple(stack) for stack in state)
        goal_key = tuple(tuple(stack) for stack in goal)

        if state_key == goal_key:
            return path

        if state_key in visited:
            continue

        visited.add(state_key)

        # Generate all possible valid moves
        for i in range(len(state)):
            if state[i]:  # Stack is not empty
                block = state[i][-1]

                for j in range(len(state)):
                    if i != j:
                        # Make a deep copy of the state
                        new_state = copy.deepcopy(state)
                        new_state[i].pop()
                        new_state[j].append(block)

                        move_desc = f"Move {block} from Stack {i+1} to Stack {j+1}"
                        stack.append((new_state, path + [move_desc]))

    return None

# Example usage
initial = [['A', 'C', 'B'], ['C', 'B', 'A'], []]
goal = [['A', 'B', 'C'], ['A', 'B', 'C'], []]

solution = blocks_world_dfs(initial, goal)

print("DFS Solution:")
if solution:
    for step in solution:
        print(step)
else:
    print("No solution found.")

def blocks_world_dls(initial, goal, limit):
    stack = [(initial, [], 0)]
    visited = set()

    while stack:
        state, path, depth = stack.pop()

        if state == goal:
            return path

        if tuple(map(tuple, state)) in visited or depth >= limit:
            continue

        visited.add(tuple(map(tuple, state)))

        if depth < limit:
            for i in range(len(state)):
                if state[i]:
                    block = state[i][-1]
                    for j in range(len(state)):
                        if i != j:
                            new_state = [list(stack) for stack in state]
                            new_state[i].pop()
                            new_state[j].append(block)
                            stack.append((new_state, path + [f"Move {block} from Stack {i+1} to Stack {j+1}"], depth+1))

    return None

initial = [['B', 'C', 'A'], ['C', 'B', 'A'], []]
solution = blocks_world_dls(initial, goal, 1)
print("\nDLS Solution (Depth=1):")
if solution:
    for step in solution:
        print(step)
else:
    print("No solution found at depth 1")

# Completeness: At depth=1, DLS is incomplete as it can't find solutions requiring more moves

def iterative_deepening(initial, goal):
    depth = 0
    while True:
        result = blocks_world_dls(initial, goal, depth)
        if result:
            print(f"\nGoal found at depth {depth}:")
            for step in result:
                print(step)
            return depth
        depth += 1

print("\nIterative Deepening Search:")
goal_depth = iterative_deepening(initial, goal)
print(f"Goal achieved at depth: {goal_depth}")

import heapq

def blocks_world_ucs(initial, goal, costs):
    heap = []
    heapq.heappush(heap, (0, initial, []))
    visited = set()

    while heap:
        cost, state, path = heapq.heappop(heap)

        if state == goal:
            return path, cost

        if tuple(map(tuple, state)) in visited:
            continue

        visited.add(tuple(map(tuple, state)))

        for i in range(len(state)):
            if state[i]:
                block = state[i][-1]
                for j in range(len(state)):
                    if i != j:
                        new_state = [list(stack) for stack in state]
                        new_state[i].pop()
                        new_state[j].append(block)
                        move_cost = costs.get(block, 1)  # Default cost 1 if not specified
                        heapq.heappush(heap, (cost + move_cost, new_state,
                                         path + [f"Move {block} from Stack {i+1} to Stack {j+1} (Cost: {move_cost})"]))

    return None, float('inf')

# Example costs for blocks
costs = {'S': 5, 'B': 15, 'C': 1, 'G': 10}
initial_ucs = [['S', 'S', 'B'], ['S', 'G'], ['C']]
goal_ucs = [['G', 'B', 'S'], ['S', 'S'], ['C']]

solution, total_cost = blocks_world_ucs(initial_ucs, goal_ucs, costs)
print("\nUniform Cost Search Solution:")
for step in solution:
    print(step)
print(f"Total cost: {total_cost}")