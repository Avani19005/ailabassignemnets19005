# -*- coding: utf-8 -*-
"""ASS2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1bKzIhTc0pdAZsqD2KeZ5l9nmbL-Cq3OK
"""

from collections import deque

def solve_8_puzzle(initial, goal):
    queue = deque()
    queue.append((initial, []))
    visited = set()
    visited.add(tuple(map(tuple, initial)))

    moves = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # Right, Down, Left, Up

    while queue:
        current, path = queue.popleft()

        if current == goal:
            return path

        # Find empty tile (0)
        for i in range(3):
            for j in range(3):
                if current[i][j] == 0:
                    x, y = i, j
                    break

        for dx, dy in moves:
            nx, ny = x + dx, y + dy
            if 0 <= nx < 3 and 0 <= ny < 3:
                new_state = [row[:] for row in current]
                new_state[x][y], new_state[nx][ny] = new_state[nx][ny], new_state[x][y]

                if tuple(map(tuple, new_state)) not in visited:
                    visited.add(tuple(map(tuple, new_state)))
                    queue.append((new_state, path + [(nx, ny)]))

    return None

# Initial and goal states
initial = [[1, 2, 3], [8, 0, 4], [7, 6, 5]]
goal = [[2, 8, 1], [0, 4, 3], [7, 6, 5]]

solution = solve_8_puzzle(initial, goal)
if solution:
    print("Solution found in", len(solution), "moves:")
    for step in solution:
        print("Move empty space to", step)
else:
    print("No solution found")

def water_jug_solver(jug1_cap, jug2_cap, target):
    visited = set()
    queue = [(0, 0, [])]  # (jug1, jug2, steps)

    while queue:
        jug1, jug2, steps = queue.pop(0)

        if jug1 == target:
            return steps

        if (jug1, jug2) in visited:
            continue

        visited.add((jug1, jug2))

        # Generate all possible next states
        next_states = [
            (jug1_cap, jug2, steps + ["Fill Jug1"]),
            (jug1, jug2_cap, steps + ["Fill Jug2"]),
            (0, jug2, steps + ["Empty Jug1"]),
            (jug1, 0, steps + ["Empty Jug2"]),
            (max(0, jug1 - (jug2_cap - jug2)), min(jug2 + jug1, jug2_cap), steps + ["Pour Jug1 to Jug2"]),
            (min(jug1 + jug2, jug1_cap), max(0, jug2 - (jug1_cap - jug1)), steps + ["Pour Jug2 to Jug1"])
        ]

        for state in next_states:
            if (state[0], state[1]) not in visited:
                queue.append(state)

    return None

# Solve for 4L and 3L jugs to get 2L in 4L jug
solution = water_jug_solver(4, 3, 2)
if solution:
    print("Solution steps:")
    for i, step in enumerate(solution, 1):
        print(f"{i}. {step}")
else:
    print("No solution found")

from itertools import permutations

def tsp(cities, start):
    n = len(cities)
    min_path = None
    min_distance = float('inf')

    # Generate all possible paths that start with the given start city
    for path in permutations([i for i in range(n) if i != start]):
        current_path = (start,) + path + (start,)
        current_distance = 0

        # Calculate total distance for this path
        for i in range(len(current_path)-1):
            current_distance += cities[current_path[i]][current_path[i+1]]

        if current_distance < min_distance:
            min_distance = current_distance
            min_path = current_path

    return min_path, min_distance

# Example cities distance matrix
cities = [
    [0, 10, 15, 20],  # City 0
    [10, 0, 35, 25],  # City 1
    [15, 35, 0, 30],   # City 2
    [20, 25, 30, 0]    # City 3
]

start = int(input("Enter starting city (0-3): "))
path, distance = tsp(cities, start)

print(f"Optimal path: {' â†’ '.join(map(str, path))}")
print(f"Total distance: {distance}")