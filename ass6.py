# -*- coding: utf-8 -*-
"""Assignment6.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1vB1izV8dQ90yZ_GAbkCznaM6T6UFaMUB
"""

class Graph:
  def __init__(self, graph, heuristic_list, start):
    self.graph = graph
    self.heuristic = heuristic_list
    self.start = start
    self.parent = {}
    self.status = {}
    self.solution = {}

  def apply_AO(self):
    """Starts the A* search with AO* optimization."""
    self.ao_star(self.start, False)

  def neighbor(self, v):
    """Returns the neighbors of a node."""
    return self.graph.get(v, [])

  def get_status(self, v):
    """Returns the processing state of a node."""
    return self.status.get(v, 0)

  def set_status(self, v, val):
    """Updates the processing state of a node."""
    self.status[v] = val

  def get_heuristic_val(self, n):
    """Retrieves the heuristic value for a node."""
    return self.heuristic.get(n, 0)

  def set_heuristic_val(self, n, value):
    """Updates the heuristic value for a node."""
    self.heuristic[n] = value

  def min_cost_node(self, v):
    """Finds the child node with the minimum cost."""
    min_cost = float('inf')
    children = []
    for neighbors in self.neighbor(v):
      cost = 0
      child_nodes = []
      for child, weight in neighbors:
        cost += self.get_heuristic_val(child) + weight
        child_nodes.append(child)
      if cost < min_cost:
        min_cost = cost
        children = child_nodes
    return min_cost, children
  def ao_star(self, v, backtrack):
    """Recursive core of the A* search with AO* optimization."""
    print("heuristic value:", self.heuristic)
    print("solution:", self.solution)
    print("processing node:", v)
    if self.get_status(v) >= 0:
      min_cost, child_nodes = self.min_cost_node(v)
      self.set_heuristic_val(v, len(child_nodes))
      solved = True
      for child in child_nodes:
        self.parent[child] = v
        if self.get_status(child) != -1:
          solved = False & solved
      if solved:
        self.set_status(v, -1)
        self.solution[v] = child_nodes
        if v != self.start:
          self.ao_star(self.parent[v], True)
      if not backtrack:
        if child_nodes:
          for child in child_nodes:
            self.set_status(child, 0)
            self.ao_star(child, False)


h1 = {'A': 1, 'B': 6, 'C': 12, 'D': 10, 'E': 4, 'F': 4, 'G': 5, 'H': 7}
graph1 = {
  'A': [[('B', 1), ('C', 1)], [('D', 1)]],
  'B': [[('G', 1)], [('H', 1)]],
  'D': [[('E', 1), ('F', 1)]]
}
g1 = Graph(graph1, h1, 'A')
g1.apply_AO()

def fitness(bag, bits, capacity):
    fit = []
    f_list = []
    n = len(bag)

    for i in range(n):
        f_value = 0
        f_weight = 0
        for j in range(len(bits[i])):
            if bits[i][j] == 1:
                f_weight += bag[j][1]
                f_value += bag[j][2]
        if f_weight <= capacity:
            fit.append(bits[i])
            f_list.append(f_value)
        else:
            f_value = 0
            fit.append(bits[i])
            f_list.append(f_value)
    swapped = True
    while swapped:
        swapped = False
        for i in range(len(f_list) - 1):
            if f_list[i] < f_list[i + 1]:
                f_list[i], f_list[i + 1] = f_list[i + 1], f_list[i]
                fit[i], fit[i + 1] = fit[i + 1], fit[i]
                swapped = True

    return fit, f_list

def crossover(fit):
        fit[2][2], fit[3][2] = fit[3][2], fit[2][2]
        fit[2][3], fit[3][3] = fit[3][3], fit[2][3]
        return fit


def mutation(fit, iteration):
    cycle = [2, 0, 3, 1]
    counter = cycle[(iteration % 4)]
    if fit[2][counter]==0:
        fit[2][counter]=1
    else:
        fit[2][counter]=0
    return fit



def genetic_algorithm(bag, bits, capacity):
    iterations=4
    for iteration in range(iterations):
        fit,f_list = fitness(bag, bits, capacity)
        fit=crossover(fit)
        fit=mutation(fit, iteration)
        bits=fit
    fit, f_list = fitness(bag, bits, capacity)
    return fit, f_list

def main():
    bag = [['A', 2, 3], ['B', 3, 5], ['C', 4, 7], ['D', 5, 9]]
    bits = [[1, 1, 1, 1], [1, 0, 0, 0], [1, 0, 1, 0], [1, 0, 0, 1]]
    capacity = 9
    fit,f_list = genetic_algorithm(bag, bits, capacity)
    print("Fit items after 4 iterations:",fit[0])
    print("Fittest cromosome:",max(f_list))
main()

import math
import random
def evaluate_sol(solution):
  clauses = [(
    (not solution[0]) or (solution[3])),
    (solution[2] or solution[1]),
    ((not solution[2]) or (not solution[3])),
    ((not solution[3]) or (not solution[1])),
    ((not solution[0]) or (not solution[3]))]
  return sum(clauses)

def movegen(solution):
  var_idx = random.randint(0,len(solution)-1)
  solution_copy = solution[:]
  solution_copy[var_idx] = not solution[var_idx]
  return solution_copy

def accept_badmove(delta,temperature):
  if delta < 0:
    return True
  probability = math.exp(-delta/temperature)
  return random.random() < probability

def simulated_annealing():
  T=500
  cooling_factor = 50
  current_sol = [True,True,True,True]
  current_energy=evaluate_sol(current_sol)
  best_sol = current_sol[:]
  best_energy = current_energy
  while T>0:
    for i in range(cooling_factor):
      new_sol = movegen(current_sol)
      new_energy = evaluate_sol(new_sol)
      delta = new_energy-current_energy
      if delta > 0 or accept_badmove(delta,T):
        current_sol=new_sol[:]
        current_energy=new_energy
        if(new_energy)>best_energy:
          best_sol=new_sol[:]
          best_energy=new_energy
    T-=1
  return best_sol

random.seed(42)
best_solution = simulated_annealing()
print("best solution",best_solution)
print("clauses satisfied",evaluate_sol(best_solution))