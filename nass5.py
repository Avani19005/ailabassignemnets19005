# -*- coding: utf-8 -*-
"""Assignment5.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1WtW0kA4QnIvHbCJAZlqNLduT2YqrtNbL
"""

# Q1
import random

def calculate_fitness(gene, item_weights, item_values, capacity):
    total_weight = 0
    total_value = 0
    for i in range(len(gene)):
        if gene[i] == '1':
            total_weight += item_weights[i]
            total_value += item_values[i]
    return 0 if total_weight > capacity else total_value

def crossover(g1, g2):
    pivot = len(g1) // 2
    return g1[:pivot] + g2[pivot:], g2[:pivot] + g1[pivot:]

def mutate(gene, flip_order, step):
    target_bit = flip_order[step % len(flip_order)]
    idx = ['W', 'X', 'Y', 'Z'].index(target_bit)
    new_gene = list(gene)
    new_gene[idx] = '0' if new_gene[idx] == '1' else '1'
    return ''.join(new_gene)

weights = {'W': 45, 'X': 40, 'Y': 50, 'Z': 90}
values = {'W': 3, 'X': 5, 'Y': 8, 'Z': 10}
capacity = 100
flip_order = ['Z', 'Y', 'X', 'W']
population = ['1111', '1000', '1010', '1001']

for gen in range(10):
    fitness = [calculate_fitness(p, list(weights.values()), list(values.values()), capacity) for p in population]
    ranked = [x for _, x in sorted(zip(fitness, population), reverse=True)]

    next_gen = ranked[:2]
    p1, p2 = ranked[2], ranked[3]
    c1, c2 = crossover(p1, p2)
    mutated = mutate(c1, flip_order, gen)
    next_gen.extend([mutated, c2])

    population = next_gen

best = max(population, key=lambda x: calculate_fitness(x, list(weights.values()), list(values.values()), capacity))
print("Final Population:", population)
print("Best Chromosome:", best, "with value:", calculate_fitness(best, list(weights.values()), list(values.values()), capacity))

# Q2
def calculate_fitness(gene, item_weights, item_values, capacity):
    total_weight = 0
    total_value = 0
    for i in range(len(gene)):
        if gene[i] == '1':
            total_weight += item_weights[i]
            total_value += item_values[i]
    return 0 if total_weight > capacity else total_value

def crossover(p1, p2):
    split = len(p1) // 2
    return p1[:split] + p2[split:], p2[:split] + p1[split:]

def mutate(gene, bit_order, turn):
    flip = bit_order[turn % len(bit_order)]
    idx = ['M', 'N', 'O', 'P'].index(flip)
    g = list(gene)
    g[idx] = '1' if g[idx] == '0' else '0'
    return ''.join(g)

weights = {'M': 2, 'N': 3, 'O': 4, 'P': 5}
values = {'M': 3, 'N': 5, 'O': 7, 'P': 9}
capacity = 9
bit_order = ['O', 'M', 'P', 'N']
population = ['1111', '1000', '1010', '1001']

for round in range(4):
    fitness = [calculate_fitness(ind, list(weights.values()), list(values.values()), capacity) for ind in population]
    sorted_pop = [x for _, x in sorted(zip(fitness, population), reverse=True)]

    next_gen = sorted_pop[:2]
    p1, p2 = sorted_pop[2], sorted_pop[3]
    c1, c2 = crossover(p1, p2)

    mutated = mutate(c1, bit_order, round)
    next_gen.extend([mutated, c2])

    population = next_gen

best = max(population, key=lambda x: calculate_fitness(x, list(weights.values()), list(values.values()), capacity))
print("Final Population:", population)
print("Best Chromosome:", best, "with value:", calculate_fitness(best, list(weights.values()), list(values.values()), capacity))

# Q2
def calculate_fitness(gene, item_weights, item_values, capacity):
    total_weight = 0
    total_value = 0
    for i in range(len(gene)):
        if gene[i] == '1':
            total_weight += item_weights[i]
            total_value += item_values[i]
    return 0 if total_weight > capacity else total_value

def crossover(p1, p2):
    split = len(p1) // 2
    return p1[:split] + p2[split:], p2[:split] + p1[split:]

def mutate(gene, bit_order, turn):
    flip = bit_order[turn % len(bit_order)]
    idx = ['M', 'N', 'O', 'P'].index(flip)
    g = list(gene)
    g[idx] = '1' if g[idx] == '0' else '0'
    return ''.join(g)

weights = {'M': 2, 'N': 3, 'O': 4, 'P': 5}
values = {'M': 3, 'N': 5, 'O': 7, 'P': 9}
capacity = 9
bit_order = ['O', 'M', 'P', 'N']
population = ['1111', '1000', '1010', '1001']

for round in range(4):
    fitness = [calculate_fitness(ind, list(weights.values()), list(values.values()), capacity) for ind in population]
    sorted_pop = [x for _, x in sorted(zip(fitness, population), reverse=True)]

    next_gen = sorted_pop[:2]
    p1, p2 = sorted_pop[2], sorted_pop[3]
    c1, c2 = crossover(p1, p2)

    mutated = mutate(c1, bit_order, round)
    next_gen.extend([mutated, c2])

    population = next_gen

best = max(population, key=lambda x: calculate_fitness(x, list(weights.values()), list(values.values()), capacity))
print("Final Population:", population)
print("Best Chromosome:", best, "with value:", calculate_fitness(best, list(weights.values()), list(values.values()), capacity))

# Q3
import math

def evaluate(state, conditions):
    satisfied = 0
    w, x, y, z = state
    for rule in conditions:
        if eval(rule):
            satisfied += 1
    return satisfied

def flip_bit(sol):
    pos = random.randint(0, 3)
    flipped = sol.copy()
    flipped[pos] = not flipped[pos]
    return flipped

clauses = [
    "(not w or z)",
    "(y or x)",
    "(not y or not z)",
    "(not z or not x)",
    "(not w or not z)"
]

current = [True, True, True, True]
score = evaluate(current, clauses)
temperature = 500
decay = lambda t: t - 50
rand_vals = [0.615, 0.274, 0.389]

for step in range(3):
    temperature = decay(temperature)
    neighbor = flip_bit(current)
    new_score = evaluate(neighbor, clauses)

    if new_score > score:
        current, score = neighbor, new_score
    else:
        delta = new_score - score
        prob = math.exp(delta / temperature)
        if rand_vals[step] > 0.5 and prob > 0.5:
            current, score = neighbor, new_score

print("Final Solution:", current)
print("Clauses Satisfied:", score)